---
title: "Exploration of Czech data"
---

This is intended as an exploration of the dataset published in Poetics. The dataset could be used for comparison of disciplines and the general scientific field. 

```{r}
lapply(list.files(here::here("R"), full.names = T), source)
lib_require("tidyverse")
lib_require("here")
lib_require("arrow")
```

For simplicity's sake, I am downloading an already calculated PCA projection of individuals. One thing to note is that this data object only contains 10 PC components. It would have been better to use all PCs, but for exploration, this should be enough. 

```{r}
pca_data <- list(
  source = "https://owncloud.cesnet.cz/index.php/s/JHZrStMPTtQcd8F/download",
  path = here::here("data", "pca_projection.RDS")
)
data_require(pca_data)  
pca_projection <- as_tibble(readRDS(pca_data$path))
```

This is the original PC object with topics in rows and disciplines in columns 
```{r}
pca_src_data <- list(
  source = "https://owncloud.cesnet.cz/index.php/s/Bf3Qqn2S2GX1AEL/download",
  path = here::here("data", "pca_src.RDS")
)
data_require(pca_src_data)
pca_src <- readRDS(pca_src_data$path)
```

Download topic distributions.

```{r}
topmodel_data <- list(
  source = "https://osf.io/download/45f2b/",
  path = here::here("data", "topic_model_202207170249_topics_level_1.feather")
)
data_require(topmodel_data)
topmodel <- arrow::read_feather(topmodel_data$path) |> select(-level)
```

This is the tricky part of the code where we try to obtain the eigenvectors of the principal components of the sub-clouds as they would appear in the original set of coordinates. 

```{r}
sub_pca <- pca_projection |> 
select(freq_ford, starts_with("PC")) |> 
rename_with(~ paste0("orig_", .x), starts_with("PC")) |> 
nest(mat = starts_with("orig_PC")) |> 
mutate(pca = map(mat, prcomp, scale = F)) |> 
mutate(axis1 = map(pca, .f = function(x) {
  rotation_matrix <- x$rotation
  # subcloud coordinates of PC1
  c(x_coord = rotation_matrix[1, 1], y_coord = rotation_matrix[2, 1])
}),
axis2 = map(pca, .f = function(x) {
  rotation_matrix <- x$rotation
  # subcloud coordinates of PC2
  c(x_coord = rotation_matrix[1, 2], y_coord = rotation_matrix[2, 2])
})) |> 
mutate(subpc1 = map(pca, .f = function(x) {
  rotation_matrix <- x$rotation
  # subcloud coordinates of PC1
  rotation_matrix[, 1]
}),
subpc2 = map(pca, .f = function(x) {
  rotation_matrix <- x$rotation
  rotation_matrix[, 2]
})) |> 
mutate(
  contr_cult_nat = abs(map_dbl(axis1, ~.x[1])),
    contr_life_nonlife = abs(map_dbl(axis1, ~.x[2]))
) |> 
mutate(contrs = map_dbl(pca, .f = function(x) {
# Calculate contributions
loadings <- x$rotation
sdev <- x$sdev
var_explained <- sdev^2

# Contribution of variables to the first principal component
contributions <- (loadings[, 1]^2) / var_explained[1]
contributions[1]
})) |> 
mutate(contrs2 = map_dbl(pca, .f = function(x) {


# Calculate contributions
loadings <- x$rotation
loadings_pc1 <- loadings[1, ]
squared_loadings_pc1 <- loadings_pc1^2
total_squared_loadings_pc1 <- sum(squared_loadings_pc1)

# Contribution of variables to the first principal component (percentage)
contributions <- (squared_loadings_pc1 / total_squared_loadings_pc1) * 100

contributions[1]
}))

sub_pca |> 
arrange(contrs2) |> 
mutate(contrs_rank = rank(contrs)) |>  # Add this line to rank contrs2
  mutate(contrs2_rank = rank(contrs2)) |>  # Add this line to rank contrs2

select(freq_ford, starts_with("contrs")) |> 
filter(!stringr::str_detect(freq_ford, "techno|ther|engineering")) |> 
print(n=42)
test <- sub_pca |> 
filter(freq_ford == "Sociology")

sub_pca$contrs
```

Here we just transform the coordinates we have obtained above into some workable form. 
```{r}
plot_data <- sub_pca |>
  select(freq_ford, axis1, axis2) |>
  tidyr::unnest_longer(starts_with("axis")) |>
  pivot_wider(names_from = c(axis1_id, axis2_id),
              values_from = c(axis1, axis2)) |>
  rename("axis1_x" = 2, "axis1_y" = 3, "axis2_x" = 4, "axis2_y" = 5) 
```


Select disciplines to focus on.
Get the means of disciplines and coordinates of all individuals 
Merge everything together 

```{r}
# unique(plot_data$freq_ford)
disc_retained <- c(
  "Languages and Literature",
  "History and Archaeology",
  "Economics and Business",
  "Electrical eng., Electronic eng., Information eng.",
  "Physical sciences",
  "Chemical sciences",
  "Biological sciences",
  "Basic medicine", 
  "Health sciences",
  "Sociology"
)
glob_data <- pca_projection |>
    filter(pubs_total >= 5)  |> 
    select(PC1, PC2, freq_ford, freq_field)

glob_means <- glob_data |> 
summarise(mean_pc1 = mean(PC1), mean_pc2 = mean(PC2), .by = freq_ford)  |> 
left_join(
  plot_data
)

plot_data_expanded <- glob_means |> 
filter(freq_ford %in% disc_retained) |> 
mutate(all = list(glob_data |> rename(freq_ford_2 = freq_ford))) |> 
unnest(cols = c(all)) |> 
mutate(disc = freq_ford == freq_ford_2) |> 
arrange(disc)   |> 
mutate(freq_ford = factor(freq_ford, levels = disc_retained))

```

Here we actually plot the beast with some ggplot code help from LLM.


```{r}
plot_all <- plot_data_expanded |> 
ggplot(aes(x = PC1, y = PC2, color = disc)) +
geom_point(size = 0.1, alpha = 0.6) +
scale_color_manual(values = c("TRUE" = "#4F4F4F", "FALSE" = "#C0C0C0")) +
  # PC 1 segment in global space
  geom_segment(
    aes(
      x = mean_pc1 - axis1_x,
      y = mean_pc2 - axis1_y,
      xend = mean_pc1 + axis1_x,
      yend = mean_pc2 + axis1_y
    ),
    color = "red", linewidth = 1 ) +
      # PC 2 segment in global space
  geom_segment(
    aes(
      x = mean_pc1 - axis2_x,
      y = mean_pc2 - axis2_y,
      xend = mean_pc1 + axis2_x,
      yend = mean_pc2 + axis2_y
    ),
    color = "blue", linewidth = 1) +

  # Add dummy geoms to create manual legend entries
  geom_segment(
    aes(x = -Inf, y = -Inf, xend = -Inf, yend = -Inf, linetype = "Subcloud PC1"),
    color = "red", linewidth = 1, show.legend = TRUE
  ) +
  geom_segment(
    aes(x = -Inf, y = -Inf, xend = -Inf, yend = -Inf, linetype = "Subcloud PC2"),
    color = "blue", linewidth = 1, show.legend = TRUE
  ) +
  scale_linetype_manual(
    values = c("Subcloud PC1" = "solid", "Subcloud PC2" = "solid"),
    guide = guide_legend(override.aes = list(color = c("red", "blue")))
  ) +
theme_minimal() +
facet_wrap(~freq_ford) 


```

Save the plot because it has too many points to be displayed interactively. 
```{r}
ggsave(here::here("output", "figures", "plot.png"), plot_all, width = 12, height = 8, bg = "white")
``` 


```{r}
library(tidytable)
topic_names <- name_topics(topmodel)
detach("package:tidytable", unload = TRUE)
``` 

```{r}
loadings_df <- as_tibble(pca_src$rotation) |>  
select(PC1, PC2) |> 
mutate(freq_ford = rownames(pca_src$rotation)) |> 
  mutate(freq_ford = abbrev_discs(freq_ford)) |> 
left_join(
  plot_data_expanded |> 
  select(freq_ford, starts_with("axis")) |> 
  distinct() |> 
  select(-starts_with("PC"))|> 
  mutate(freq_ford = abbrev_discs(freq_ford))
  )  |> 
  mutate(freq_ford_2 = ifelse(is.na(axis1_x), "other", freq_ford)) |> 
  mutate(across(starts_with("axis"), ~.x*0.3)) |> 
  na.omit() |> 
  select(-freq_ford) |> 
  mutate(others = list(as_tibble(pca_src$rotation) |>  
select(PC1x = PC1, PC2y = PC2) |> 
mutate(freq_ford = rownames(pca_src$rotation)) |> 
  mutate(freq_ford_1 = abbrev_discs(freq_ford)) )) |> 
  unnest(cols = "others")
```

Original Loadings
```{r}
# Plot loadings
ggplot(loadings_df, aes(x = PC1x, y = PC2y)) +
  geom_point() +
  geom_text(aes(label = freq_ford), size = 2.5, hjust = 1.1, vjust = 1.1) +
    geom_segment(
    aes(
      x = 0 - axis1_x,
      y = 0 - axis1_y,
      xend = 0 + axis1_x,
      yend =  axis1_y
    ), color = "red", linewidth = 1 ) +
        geom_segment(
    aes(
      x = 0 - axis2_x,
      y = 0 - axis2_y,
      xend = 0 + axis2_x,
      yend =  axis2_y
    ), color = "blue", linewidth = 1 ) +
  labs(title = "", x = "PC1", y = "PC2") +
  theme_minimal() +
  facet_wrap(~freq_ford_2)
``` 

original scores
```{r}
scores_df <- as_tibble(pca_src$x) |>  
  select(PC1, PC2) |> 
  mutate(topic = rownames(pca_src$x)) |> 
  left_join(
    topic_names  |> 
    mutate(topic_desc = stringr::str_trunc(topic_desc, 10))
  ) 
coords_df <-   plot_data_expanded |> 
  select(freq_ford, starts_with("axis")) |> 
  distinct() |> 
  select(-starts_with("PC"))

topic_plot <- ggplot(scores_df, aes(x = PC1, y = PC2)) +
  geom_text(aes(label = topic_desc),check_overlap = TRUE,size = 2) +
    geom_segment(
      data = coords_df |>  mutate(across(starts_with("axis"), ~.x*5)),
    aes(
      x = 0 - axis1_x,
      y = 0 - axis1_y,
      xend = 0 + axis1_x,
      yend =  axis1_y
    ), color = "red", linewidth = 1 ) +
        geom_segment(
           data = coords_df|>  mutate(across(starts_with("axis"), ~.x*4)),
    aes(
      x = 0 - axis2_x,
      y = 0 - axis2_y,
      xend = 0 + axis2_x,
      yend =  axis2_y
    ), color = "blue", linewidth = 1 ) +
  labs(title = "", x = "PC1", y = "PC2") +
  theme_minimal() 
topic_plot +
  facet_wrap(~freq_ford)
```


```{r}
# Create the plot
ellipses_plot <- glob_data |> 
  filter(freq_ford %in% disc_retained) |> 
  mutate(PC1 = scale(PC1), PC2 = scale(PC2)) |> 
  ggplot(aes(PC1, PC2, group = freq_ford, color = freq_ford)) +
  geom_point(data = glob_data |> mutate(PC1 = scale(PC1), PC2 = scale(PC2)), color = "lightgrey") +
  stat_ellipse(type = "norm") +
  theme_minimal()

# Extract the ellipse data
ellipse_data <- ggplot_build(ellipses_plot)$data[[2]]

# Create a mapping from group numbers to freq_ford labels
group_mapping <- glob_data |> 
  filter(freq_ford %in% disc_retained) |> 
  distinct(freq_ford) |> 
  mutate(group = as.numeric(as.factor(freq_ford)))

# Ensure the group names are correctly assigned to the ellipse data
ellipse_coords <- ellipse_data |> 
  select(x, y, group) |> 
  left_join(group_mapping, by = "group") |> 
  mutate(freq_ford = abbrev_discs(freq_ford))

# You can now use these coordinates in another plot
scores_df |> 
  mutate(PC1 = scale(PC1)[,1], PC2 = scale(PC2)[,1]) |> 
  ggplot(aes(x = PC1, y = PC2)) +
  geom_text(aes(label = topic_desc), check_overlap = TRUE, size = 2) +
  geom_path(data = ellipse_coords, 
  aes(x, y, group = group, color = freq_ford)) +
  theme_minimal()

```


```{r}
scores_df_norm <- scores_df  |> 
mutate(PC1 = scale(PC1)[,1], PC2 = scale(PC2)[,1]) 


# Function to check if a point is inside a polygon using the ray-casting algorithm
is_point_in_polygon <- function(point, polygon) {
  n <- nrow(polygon)
  inside <- FALSE
  j <- n
  for (i in 1:n) {
    if (((polygon$y[i] > point[2]) != (polygon$y[j] > point[2])) &&
        (point[1] < (polygon$x[j] - polygon$x[i]) * (point[2] - polygon$y[i]) / (polygon$y[j] - polygon$y[i]) + polygon$x[i])) {
      inside <- !inside
    }
    j <- i
  }
  return(inside)
}

unique(ellipse_coords$freq_ford)
focal_disc <- "LangLit"
# Filter ellipse_coords for the specific group
ellipse_coords_langlit <- ellipse_coords |> filter(freq_ford == focal_disc)

# Filter scores_df_norm for points within the ellipse
scores_within_ellipse <- scores_df_norm |> 
  rowwise() |> 
  filter(is_point_in_polygon(c(PC1, PC2), ellipse_coords_langlit))  |> 
  ungroup()

axis_means <- scores_within_ellipse |> 
  summarise(PC1x = mean(PC1), PC2y = mean(PC2))


coords_df_norm <- coords_df |> 
mutate(freq_ford = abbrev_discs(freq_ford)) |> 
filter(freq_ford == focal_disc) 


# Plot the observations that fall within the ellipse by group
ggplot(scores_within_ellipse, aes(x = PC1, y = PC2)) +
  geom_text(aes(label = topic_desc), check_overlap = TRUE, size = 3) +
    geom_path(data = ellipse_coords_langlit, aes(x, y, group = group, color = freq_ford)) +
        geom_segment(
      data = coords_df_norm |>  mutate(across(starts_with("axis"), ~.x)),
    aes(
      x = axis_means$PC1x - axis1_x,
      y = axis_means$PC2y  - axis1_y,
      xend = axis_means$PC1x + axis1_x,
      yend =  axis_means$PC2y + axis1_y
    ), color = "red", linewidth = 1 ) +
        geom_segment(
           data = coords_df_norm|>  mutate(across(starts_with("axis"), ~.x)),
    aes(
      x = axis_means$PC1x - axis2_x,
      y = axis_means$PC2y - axis2_y,
      xend = axis_means$PC1x + axis2_x,
      yend = axis_means$PC2y + axis2_y
    ), color = "blue", linewidth = 1 ) +
    theme_minimal()

```

Try to get topic loadings

```{r}

scores_for_loadings <- as_tibble(pca_src$x) |>  
  mutate(topic = rownames(pca_src$x)) |> 
  left_join(
    topic_names  |> 
    mutate(topic_desc = stringr::str_trunc(topic_desc, 10))
  ) 
scores_for_loadings

coefficients_subpc1 <- sub_pca |> 
mutate(freq_ford = abbrev_discs(freq_ford)) |> 
filter(freq_ford == focal_disc)  |> 
pull(subpc1) |> unlist() 

coefficients_subpc2 <- sub_pca |> 
mutate(freq_ford = abbrev_discs(freq_ford)) |> 
filter(freq_ford == focal_disc)  |> 
pull(subpc2) |> unlist()

# Calculate loadings for subpc1 and subpc2
loadings_subpc1 <- scores_for_loadings[,1:10] %>%
  as.matrix() %*% coefficients_subpc1

loadings_subpc2 <- scores_for_loadings[,1:10] %>%
  as.matrix() %*% coefficients_subpc2

# Combine loadings into a data frame
loadings_df <- tibble(topic = scores_for_loadings$topic, loadings_subpc1 = loadings_subpc1[,1], loadings_subpc2 = loadings_subpc2[,1]) |> 
  mutate(
    squared_loadings_subpc1 = sign(loadings_subpc1) * (loadings_subpc1^2),
    scaled_squared_loadings = scales::rescale(abs(squared_loadings_subpc1)),
    z_loadings_subpc1 = scale(loadings_subpc1),
    abs_loadings_subpc1 = abs(loadings_subpc1),  # Take absolute value
    scaled_loadings_subpc1 = scales::rescale(abs_loadings_subpc1) 
  )

scores_within_ellipse2 <- scores_within_ellipse |> 
left_join(loadings_df) |> 
left_join(topic_names |> rename(topic_desc2 = topic_desc))

ggplot(scores_within_ellipse2, aes(x = PC1, y = PC2)) +
  geom_text(aes(label = topic_desc, size = abs(z_loadings_subpc1)), check_overlap = TRUE) +
    geom_path(data = ellipse_coords_langlit, aes(x, y, group = group, color = freq_ford)) +
        geom_segment(
      data = coords_df_norm |>  mutate(across(starts_with("axis"), ~.x)),
    aes(
      x = axis_means$PC1x - axis1_x,
      y = axis_means$PC2y  - axis1_y,
      xend = axis_means$PC1x + axis1_x,
      yend =  axis_means$PC2y + axis1_y
    ), color = "red", linewidth = 1 ) +
        geom_segment(
           data = coords_df_norm|>  mutate(across(starts_with("axis"), ~.x)),
    aes(
      x = axis_means$PC1x - axis2_x,
      y = axis_means$PC2y - axis2_y,
      xend = axis_means$PC1x + axis2_x,
      yend = axis_means$PC2y + axis2_y
    ), color = "blue", linewidth = 1 ) +
    theme_minimal()

```